// Sys.vm
// Student ID: 201860766

// Sys.xor
function Sys.xor 0
// 实际实现需逐位计算异或，建议参考Sys.computeParity的位操作逻辑
// 以下为伪代码框架：
function Sys.xor 0
    @SP
    AM=M-1
    D=M
    @SP
    AM=M-1
    A=M
    
    @result
    M=0
    @i
    M=0
    
    (XOR_LOOP)
    @i
    D=M
    @15
    D=A-D
    @END_XOR
    D;JLE
    
    @a
    M=A
    D=M
    @1
    D=D&M
    
    @i
    M=M+1
    @XOR_LOOP
    0;JMP
    
    (END_XOR)
    @result
    D=M
    @SP
    A=M
    M=D
    @SP
    M=M+1


// Sys.shiftLeft 2
function Sys.shiftLeft 0
    @SP
    AM=M-1
    D=M
    @y
    M=D
    
    @SP
    AM=M-1
    D=M
    @x
    M=D
    
    @i
    M=0
    
    (LOOP)
    @i
    D=M
    @y
    D=D-M
    @END
    D;JGE
    
    @x
    D=M
    D=D+D
    @x
    M=D
    
    @i
    M=M+1
    @LOOP
    0;JMP
    
    (END)
    @x
    D=M
    @SP
    A=M-1
    M=D
    @SP
    M=M+1


// Sys.computeParity
function Sys.computeParity 0
    @SP
    AM=M-1
    D=M
    
    @mask
    M=0x7FFF
    D=D&M
    
    @parity
    M=0
    @i
    M=0
    
    (LOOP)
    @i
    D=M
    @15
    D=A-D
    @END
    D;JLE
    

    @1
    D=A
    @i
    D=D<<M
    @temp
    M=D
    
    @input
    M=D
    D=M&temp
    
    @SKIP
    D;JEQ
    @parity
    M=!M
    
    (SKIP)
    @i
    M=M+1
    @LOOP
    0;JMP
    
    (END)
    @parity
    D=M
    @15
    D=D<<M
    
    @SP
    A=M
    M=D
    @SP
    M=M+1


// Sys.encode
function Sys.encode 0
    @SP
    AM=M-1
    D=M
    @input
    M=D

    @input
    D=M
    @ARG0
    M=D
    @Sys.computeParity
    0;JMP
    
    @SP
    AM=M-1
    D=M
    @parity
    M=D
    
    @input
    D=M
    
    @parity
    D=D<<15
    D=D|M
    
    @SP
    A=M
    M=D
    @SP
    M=M+1